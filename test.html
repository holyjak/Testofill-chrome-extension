<html>
    <head>
        <title>Testofill test</title>
        <script src="chance.min.js"></script>
        <script src="src/lib/underscore-min.js"></script>
    </head>
    <body>
        <h3>Food preferences</h3>
        <form>
            <p>
            <input type="text" name="q" id="$box" placeholder="My favourite meal name" size="30">
            </p><p>
            Soup?<input type="CHECKBOX" name="chboxin" id="$chboxin" value="checkbox1"><em>(-&gt; checked)</em>
            Poisonous?<input type="CHECKBOX" name="chboxin_poisonous" id="$chboxin_poisonous" value="xy" checked><em>(-&gt; unchecked)</em>
            </p><p>
            Preferred: <input type="RADIO" name="radioin" value="radio1_on" checked>Brokkoli
            <input type="RADIO" name="radioin" value="radio2_off">Tomatoes
            <em>(-&gt; Tomatoes)</em>
            </p><p>
            Eat at: <input type="RADIO" name="radioin_none" value="1" checked>Park
            <input type="RADIO" name="radioin_none" value="2">Home
            <em>(De-select so that nothing selected)</em>
            </p><p>
            <label>Image: <input type="file" id="$file" name="filein"><em>(unsupported?)</em></label>
            <input type="hidden" name="hiddenin" id="$hiddenin">
            </p><p>
            <input type="password" name="passwordin" id="$passwordin" placeholder="Random password">
            </p><p>
            Spiceness: <select name="selectin" id="$selectin">
                <option value="hot">Hot</option>
                <option value="veryhot">Very hot</option>
            </select><em>(-&gt; very hot)</em>
            </p><p>
            Use: <select name="selectin_none" id="$selectin_none">
                <option value="">Select one</option>
                <option value="knife">Knife &amp; fork</option>
                <option value="hands" selected>Hands</option>
            </select><em>(-&gt; De-select so that nothing selected)</em>
            </p><p>
            Select 0+: <select name="selectmultiin" id="$selectmultiin" multiple="true" size="2">
                <option value="lassi">Lassi</option>
                <option value="raita">Raita</option>
            </select><em>(-&gt; Select all)</em>
            </p><p>
            <input type="reset" value="Reset" id="$reset"/>
            <input type="submit" value="Submit" id="$submit"/>
            </p>
        </form>

        Rules for this form:
        <code><pre>
{
  "forms": {
    "me:1111/test.html.*#one": [
      {
        "fields": [
          {
            "query": "[name='q']",
            "value": "Palak paneer"
          },
          {
            "query": "[name='chboxin']",
            "value": true
          },
          {
            "query": "[name='chboxin_poisonous']",
            "value": false
          },
          {
            "query": "[name='radioin']",
            "value": "radio2_off"
          },
          {
            "query": "[name='radioin_none']",
            "value": null
          },
          {
            "query": "[name='hiddenin']",
            "value": "Hidden message"
          },
          {
            "query": "[name='passwordin']",
            "value": "Secr3t!"
          },
          {
            "query": "[name='selectin']",
            "value": "veryhot"
          },
          {
            "query": "[name='selectin_none']",
            "value": null
          },
          {
            "query": "[name='selectmultiin']",
            "value": ["lassi", "raita"]
          }
        ],
        "name": "Bob the Test Manager"
      }
    ],
    "me:1111/test.html.*#two": [
      {
        "doc": "Register as the test manager Bob",
        "fields": [
          {
            "query": "[name='q']",
            "value": "Testofill rocks!"
          }
        ],
        "name": "Bob the Test Manager"
      },
      {
        "fields": [
          {
            "query": "[name='q']",
            "value": "Value from another ruleSet"
          }
        ],
        "name": "Another"
      }
    ]
  }
}
        </pre></code>

        <script>

            var generateFns = {
                "chance.natural": [chance.natural, chance],
                "chance.integer": [chance.integer, chance],
                "chance.bool": [chance.bool, chance],
                "chance.character": [chance.character, chance],
                "chance.pick": [chance.pick, chance]
            };

            function parseGenExpr(expr) {

                // Is this a fn call?
                var maybeFn = isFnCall(expr);
                if (maybeFn) {
                    var name = expr[0];
                    expr.shift();
                    return parseGenFn(maybeFn, expr);
                }

                // Other, non-fn call
                return parseGenVal(expr);

            }

            function isFnCall(expr) {
                if (_.isArray(expr) && !_.isEmpty(expr) && _.isString(expr[0])) {
                    var maybeName = expr[0];
                    var maybeFn = generateFns[maybeName];
                    if (maybeFn) {
                        return maybeFn;
                    }
                }
                return false;
            }

            /**
             * Note: Nested arrays parsed too; literal array not parsed: {array: [...]}
             */
            function parseGenFn(fn, args) {

                var argsParsed = _.chain(args)
                    .map(function(e){
                        // nested fn call?
                        if (_.isArray(e)) return parseGenExpr(e); // array but not fn call
                        // literal array?
                        //if (_.isObject(e) && _.has(e, 'array') && _.keys(e).length === 1 ) return e.array;
                        // parsed nested (1 level only)
                        if (_.isObject(e)){
                            return _.chain(e).pairs().map(function(nameVal){
                                var val = nameVal[1];
                                var maybeFn = isFnCall(val);
                                if (maybeFn) {
                                    val.shift();
                                    val = parseGenFn(maybeFn, val);
                                }
                                return [nameVal[0], nameVal[1]];
                            })
                            .object().value();
                        }
                        return e;
                    })
                    .value();

                return fn[0].apply(fn[1], argsParsed);
            }

            /** Parse non-fn call: literal array or literal value */
            function parseGenVal(expr) {
                return _.chain(expr)
                    .map(function(e){
                        if (_.isString(e)) return e;
                        if (_.isArray(e)) return parseGenExpr(e); // array but not fn call
                        throw {expr: expr, e: e, msg: "Cannot parse, only supports string/array here, got " + (typeof e)};
                    })
                    .reduce(function(acc,str){return acc.concat(str);}, "")
                    .value();
            }

            // EX:
            var generate = ["+47", ["chance.natural", {"min": 10000000,"max":99999999}]];
            // OK mixed: ["+47", ["chance.natural", {"min": 10000000,"max":99999999}]];
            // OK top fn call ["chance.integer"]
            // OK ["1"], ["1","2"]
            // OK ["chance.natural", {"min": ["chance.natural"]}] - 1 lvl nesting only!!!
            // NOT ["chance.pick", [1,2,3]] - not strings
            // NOT ["chance.pick", [true,false]] - not strings
            // NOT SUPPORTED:
            // - non-strings, e.g. [1]


            // =>
            // var fn = generateFns['chance.natural']
            // fn[0].apply(fn[1], {"min": 10000000,"max":99999999})

            console.log("Parsed: ", parseGenExpr(generate));



        </script>
    </body>
</html>

